library(svDialogs)
library(ggplot2)
library(tidyr)
library(plyr)
library(gganimate)
library(transformr)
library(dplyr)
library(tidyverse)
library(broom)
library(magick)
library(patchwork)
library(lubridate)
library(zoo)
library(ggsignif)
library(qpcR)
library(car) 
library(FSA)
library(ggrepel)
library(gridExtra) # merge plots
library(ggdendro) # dendrograms
library(gplots) # heatmap
library(tseries) # bootstrap
library(TSclust) # cluster time series
library(dtwclust) # cluster time series with dynamic time warping
library(tibble)
library(data.table)
library(chisq.posthoc.test)


#data grabbing ####
input_directory <- choose.dir(default = getwd(), caption = "Select the folder that contains all your data (e.g. plaque_1") #prompts the user to identify directory containing the directory containing all the .csv data to be analysed
setwd(input_directory) 
dir.create(file.path("R_output/"))  #creates a directory for outputs
output_directory <- paste0(file.path(input_directory, "R_output/"))
setwd(input_directory)
temp1 <- list.files(path = input_directory, pattern = ".csv", recursive = T) #creates a list of all the .csv files in the input directory

#Prompts the user to enter two user inputted strings separated by a comma (with no spaces). These elements should be strings contained in the filenames  
#that are unique to that specific condition. This format has been chosen because it's the native naming convention of wells generated by a JOB in NIS-elements
condition_1 <- "04,08,12"
condition_2 <- "03,07,11"
condition_3 <- "02,06,10"
condition_4 <- "05,09"
control <- "01"

condition_1_split <- str_split_fixed(condition_1, ",", 3)
condition_2_split <- str_split_fixed(condition_2, ",", 3)
condition_3_split <- str_split_fixed(condition_3, ",", 3)
condition_4_split <- str_split_fixed(condition_4, ",", 2)
condition_1_1 <- paste0("_",condition_1_split[1],"_")
condition_1_2 <- paste0("_",condition_1_split[2],"_")
condition_1_3 <- paste0("_",condition_1_split[3],"_")

condition_2_1 <- paste0("_",condition_2_split[1],"_")
condition_2_2 <- paste0("_",condition_2_split[2],"_")
condition_2_3 <- paste0("_",condition_2_split[3],"_")

condition_3_1 <- paste0("_",condition_3_split[1],"_")
condition_3_2 <- paste0("_",condition_3_split[2],"_")
condition_3_3 <- paste0("_",condition_3_split[3],"_")

condition_4_1 <- paste0("_",condition_4_split[1],"_")
condition_4_2 <- paste0("_",condition_4_split[2],"_")

control_1 <- paste0("_",control,"_")

#SEPARATE FILES BASED ON CONDITION/TREATMENT
#breaks up the last of input directory files based on the user inputted strings above
filenames_condition_1 <- Filter(function(x) grepl(condition_1_1, x)&!grepl("_background", x)|grepl(condition_1_2, x)&!grepl("_background", x)|grepl(condition_1_3, x)&!grepl("_background", x), temp1)
filenames_condition_2 <- Filter(function(x) grepl(condition_2_1, x)&!grepl("_background", x)|grepl(condition_2_2, x)&!grepl("_background", x)|grepl(condition_2_3, x)&!grepl("_background", x), temp1)
filenames_condition_3 <- Filter(function(x) grepl(condition_3_1, x)&!grepl("_background", x)|grepl(condition_3_2, x)&!grepl("_background", x)|grepl(condition_3_3, x)&!grepl("_background", x), temp1)
filenames_condition_4 <- Filter(function(x) grepl(condition_4_1, x)&!grepl("_background", x)|grepl(condition_4_2, x)&!grepl("_background", x), temp1)
filenames_control <- Filter(function(x) grepl(control_1, x)&!grepl("_background", x), temp1)
filenames_background <- Filter(function(x) grepl("_background", x), temp1)

#READ DATA INTO TABLES
mydata_assembled_condition_1 <- data.table:::rbindlist(lapply(filenames_condition_1, read.csv), use.names=FALSE) 
mydata_assembled_condition_2 <- data.table:::rbindlist(lapply(filenames_condition_2, read.csv), use.names=FALSE)
mydata_assembled_condition_3 <- data.table:::rbindlist(lapply(filenames_condition_3, read.csv), use.names=FALSE)
mydata_assembled_condition_4 <- data.table:::rbindlist(lapply(filenames_condition_4, read.csv), use.names=FALSE)
mydata_assembled_condition_control <- data.table:::rbindlist(lapply(filenames_control, read.csv), use.names=FALSE)
mydata_assembled_background <- data.table:::rbindlist(lapply(filenames_background, read.csv), use.names=FALSE)

#dplyr:::select(where(~!any(is.na(.))))


df_list <- list(mydata_assembled_condition_1,mydata_assembled_condition_2,mydata_assembled_condition_3, mydata_assembled_condition_4,
                mydata_assembled_condition_control) #put above dfs into a list for use in loop functions
condition_list <- list("MOI1","MOI10","MOI50", "MOI100", "uninfected")#create a list of condition names for use in loop functions

#data wrangling####
condition_data_prepper = function(x, var) {
  x %>% 
    dplyr:::mutate(TrackObjects_Label = na_if(TrackObjects_Label, "NaN")) %>% #change cellprofiler's 'NaN' representation to R recognised 'NA'
    filter(!is.na(TrackObjects_Label)) %>% #remove NAs from the dataset
    unite("FoV_ID", Metadata_Date, Metadata_Well_ID, Metadata_FoV_ID, remove=FALSE)%>% #constructing unique_ID columns that can be used to group rows for various purposes (e.g. by cell, by FoV, etc)
    unite("unique_ID", FoV_ID, TrackObjects_Label, remove=FALSE)%>%
    unite("FoV_Frame_ID", FoV_ID, Metadata_Frame, remove=FALSE) %>% 
    mutate(Condition = var) #set the Condition name
} 

condition_data <- map2(.x=df_list, .y=condition_list, .f=condition_data_prepper) #Loops .f over each pairwise combination of .x and .y. Output is a list of dfs

#Calculates the mean background intensity per pixel for each time point using measurements taken by masking cells in original images
background_data <- mydata_assembled_background %>% 
  dplyr:::rename(green_background=Intensity_MeanIntensity_green_background,
                 red_background=Intensity_MeanIntensity_red_background) %>% 
  unite("FoV_ID", Metadata_Date, Metadata_Well_ID, Metadata_FoV_ID, remove=FALSE)%>% #constructing unique_ID columns that can be used to group rows for various purposes (e.g. by cell, by FoV, etc)
  unite("FoV_Frame_ID", FoV_ID, Metadata_Frame, remove=FALSE) %>% 
  dplyr:::select(FoV_Frame_ID, green_background, red_background)

#Stacks data for multiple conditions into a single df
#Filters any tracks that split (i.e. number of rows of data per cell != 145),
#and any tracks that don't have 145 unique time points.
#LinkType filter removes any objects recognised by LAP tracker as children of a split or mitosis  

extract_relevant_columns=function(df1, area_multiplier, intensity_multiplier) {
  temp1 <- df1 %>% dplyr:::select(Metadata_T, Metadata_Frame, unique_ID, Intensity_MeanIntensity_Red, #select all useful columns
                                  Intensity_MeanIntensity_Green, Intensity_IntegratedIntensity_Green, 
                                  Intensity_IntegratedIntensity_Red,AreaShape_Area, TrackObjects_IntegratedDistance, 
                                  AreaShape_MeanRadius, Condition, AreaShape_Eccentricity, 
                                  AreaShape_Compactness, Location_Center_X, Location_Center_Y, TrackObjects_Displacement, 
                                  Metadata_Date.1, FoV_ID,TrackObjects_Lifetime, FoV_Frame_ID, Metadata_Well_ID) %>% 
    unite("FoV_Frame_unique_ID",unique_ID, Metadata_Frame, remove=FALSE) %>% 
    group_by(FoV_Frame_unique_ID) %>% 
    dplyr:::mutate(duplicated = n()>1) %>% #creates a logical that identifies whether any given time point has more than one row with the same unique_ID
    group_by(unique_ID) %>% 
    dplyr:::filter(mean(duplicated)<0.2) %>%  #removes any unique_ID that had any time point with more than one row
    dplyr:::filter(!any((AreaShape_Area > lag(AreaShape_Area)*area_multiplier), na.rm=T))%>% #aimed at filtering out any mis-segmented and aberrantly merged cells 
    dplyr:::filter(!any((Intensity_IntegratedIntensity_Red-lag(Intensity_IntegratedIntensity_Red, k=3)>intensity_multiplier), na.rm=T)) 
   }

data_merged_intermediate <- map(condition_data, extract_relevant_columns, area_multiplier=5, intensity_multiplier=100)%>% #loops extract_relevant_columns over all the dfs in the condition_data list
  bind_rows() %>% #merges the list of dfs from map() into a single df
  left_join(., background_data, by="FoV_Frame_ID") %>% #joins the background data df, adding a column that contains a discrete value of background intensity for every unique intersection of time, well_ID, FoV_ID
  mutate(HPI = (Metadata_Frame*10)/60)

data_merged<- data_merged_intermediate %>% #converts frame to time in hours
  group_by(unique_ID) %>% 
  #filter(Metadata_Frame<217) 
  filter(n_distinct(Metadata_Frame)>180) %>% 
  mutate(normalised_sum_red=(Intensity_IntegratedIntensity_Red-(red_background*AreaShape_Area))) %>% #uses the background value added above to normalise red
  mutate(normalised_sum_green=(Intensity_IntegratedIntensity_Green-(green_background*AreaShape_Area))) %>% #uses the background value added above to normalise green
  mutate(normalised_mean_red=(Intensity_MeanIntensity_Red-red_background)) %>% #uses the background value added above to normalise red
  mutate(normalised_mean_green=(Intensity_MeanIntensity_Green-green_background)) #uses the background value added above to normalise green

extract_relevant_columns_co=function(df1, area_multiplier, intensity_multiplier) {
  temp1 <- df1 %>% dplyr:::select(Metadata_T, Metadata_Frame, unique_ID, Intensity_MeanIntensity_Red, #select all useful columns
                                  Intensity_MeanIntensity_Green, Intensity_IntegratedIntensity_Green, 
                                  Intensity_IntegratedIntensity_Red,AreaShape_Area, TrackObjects_IntegratedDistance, 
                                  AreaShape_MeanRadius, Condition, AreaShape_Eccentricity, 
                                  AreaShape_Compactness, Location_Center_X, Location_Center_Y, TrackObjects_Displacement, 
                                  Metadata_Date.1, FoV_ID,TrackObjects_Lifetime, FoV_Frame_ID, Metadata_Well_ID) %>% 
    unite("FoV_Frame_unique_ID",unique_ID, Metadata_Frame, remove=FALSE) %>% 
    group_by(FoV_Frame_unique_ID)
}
data_merged_intermediate_CO <- map(condition_data, extract_relevant_columns_co, area_multiplier=5, intensity_multiplier=100)%>% #loops extract_relevant_columns over all the dfs in the condition_data list
  bind_rows() %>% #merges the list of dfs from map() into a single df
  left_join(., background_data, by="FoV_Frame_ID") %>% #joins the background data df, adding a column that contains a discrete value of background intensity for every unique intersection of time, well_ID, FoV_ID
  mutate(HPI = (Metadata_Frame*10)/60) %>% 
  dplyr::filter(Condition=="uninfected") 

data_merged_CO<- data_merged_intermediate_CO %>% #converts frame to time in hours
  group_by(unique_ID) %>% 
  #filter(Metadata_Frame<217) 
  filter(n_distinct(Metadata_Frame)>100) %>% 
  mutate(normalised_sum_red=(Intensity_IntegratedIntensity_Red-(red_background*AreaShape_Area))) %>% #uses the background value added above to normalise red
  mutate(normalised_sum_green=(Intensity_IntegratedIntensity_Green-(green_background*AreaShape_Area))) %>% #uses the background value added above to normalise green
  mutate(normalised_mean_red=(Intensity_MeanIntensity_Red-red_background)) %>% #uses the background value added above to normalise red
  mutate(normalised_mean_green=(Intensity_MeanIntensity_Green-green_background)) #uses the background value added above to normalise green


#Calculates cutoff to identify cells as infected or uninfected based on mean and sd drawn from uninfected cells, and a user inputted multiplier
cutoff=function(df, channel, multiplier, replace = FALSE, weight=NULL) {
  mean <- df %>% 
    filter(Condition=="uninfected") %>% 
    #filter(Metadata_Frame<24) %>%  #data before 2 hpi is impacted by an unexplained spike in red and green signal
    pull({{ channel }}) %>% 
    mean(na.rm=TRUE)
  sd <- df %>% 
    filter(Condition=="uninfected") %>% 
    #filter(Metadata_Frame<24) %>%  #data before 2 hpi is impacted by an unexplained spike in red and green signal
    pull({{ channel }}) %>% 
    sd(na.rm=TRUE)
  mean*multiplier+sd*multiplier
}
cutoff_score_red <- cutoff(data_merged_CO, normalised_sum_red, 3.5) #multiplier is determined by trial and error. The lowest multiplier that yields zero uninfected control cells being identified as infected is chosen.
cutoff_score_green <- cutoff(data_merged_CO, normalised_sum_green, 3.5)

#uses the cutoffs calculated by cutoff() to label cells as infected Y/N, productive Y/N
worked_filtered_infection_Scored <- data_merged %>% 
  dplyr:::group_by(unique_ID) %>% 
  dplyr:::mutate(Infected = if_else((any(normalised_sum_red>cutoff_score_red)), "YES", "NO")) %>% 
  dplyr:::mutate(productive = if_else((any(normalised_sum_green>cutoff_score_green)), "YES", "NO"))

#Calculates the proportion of infected cells for the specified condition 
#based on the cutoff calculated above
infected_proportion <- function(df, var) {
  # Filter the data for the specific condition
  df_condition <- df %>%
    dplyr::filter(Condition == var) %>%
    arrange(unique_ID) %>%
    filter(row_number()==1)
  
  # Group by unique_ID and FoV_ID, then count the number of "NO" and "YES" infected cells
  counts <- df_condition %>%
    group_by(FoV_ID, Condition) %>%
    dplyr::summarise(no = sum(Infected == "NO", na.rm = TRUE),
              yes = sum(Infected == "YES", na.rm = TRUE),
              Metadata_Well_ID=first(Metadata_Well_ID),
              .groups = 'drop')
  
  # Calculate the proportion of infected cells
  counts <- mutate(counts, proportion = yes / (yes + no))
  
  return(counts)
}
conditions <- unique(worked_filtered_infection_Scored$Condition)
infected_score <- map_dfr(conditions, ~infected_proportion(worked_filtered_infection_Scored, .)) 
summary_i_score<- infected_score %>% 
  group_by(Condition) %>% 
  dplyr::summarise(n=sum(yes),
                   average=mean(proportion))

productive_proportion <- function(df, var) {
  # Filter the data for the specific condition
  df_condition <- worked_filtered_infection_Scored %>%
    filter(Infected=="YES") %>% 
    dplyr::filter(Condition == var) %>%
    arrange(unique_ID) %>%
    filter(row_number()==1)
  
  
  # Group by unique_ID and FoV_ID, then count the number of "NO" and "YES" infected cells
  counts <- df_condition %>%
    group_by(FoV_ID, Condition) %>%
    dplyr::summarise(no = sum(productive == "NO", na.rm = TRUE),
              yes = sum(productive == "YES", na.rm = TRUE),
              Metadata_Well_ID=first(Metadata_Well_ID),
              .groups = 'drop')
  
  # Calculate the proportion of infected cells
  counts <- mutate(counts, proportion = yes / (yes + no))
  
  return(counts)
}
productive_score <- map_dfr(conditions, ~productive_proportion(worked_filtered_infection_Scored, .))
summary_p_score<- productive_score %>% 
  group_by(Condition) %>% 
  dplyr::summarise(n=sum(yes),
                   average=mean(proportion))

sample_n_groups = function(grouped_df, size, replace = FALSE, weight=NULL) {
  grp_var <- grouped_df %>% 
    groups %>%
    unlist %>% 
    as.character
  random_grp <- grouped_df %>% 
    summarise() %>% 
    sample_n(size, replace, weight) %>% 
    mutate(unique_id = 1:NROW(.))
  grouped_df %>% 
    right_join(random_grp, by=grp_var) %>% 
    group_by_(grp_var) 
}

#Plot ready data ####
temp1<-worked_filtered_infection_Scored %>%
  group_by(unique_ID) %>%
  filter(normalised_sum_red > cutoff_score_red) %>% 
  slice_min(order_by=Metadata_Frame) %>% 
  mutate(start_time=Metadata_Frame) %>% 
 dplyr:::select(unique_ID, start_time) #calculate infection start time for every infected cell
temp2<-worked_filtered_infection_Scored %>%
  group_by(unique_ID) %>%
  filter(normalised_sum_green > cutoff_score_green) %>% 
  slice_min(order_by=Metadata_Frame) %>% 
  mutate(start_time_green=Metadata_Frame) %>% 
  dplyr:::select(unique_ID, start_time_green)

plot_data <- worked_filtered_infection_Scored %>% 
  group_by(unique_ID) %>% 
  dplyr:::mutate(remove = if_else(normalised_sum_green>50 & Metadata_Frame<10, "YES", "NO")) %>% 
  dplyr:::filter(!any(remove=="YES")) %>% 
  filter(Condition!= "uninfected") %>% 
  filter(Infected == "YES") %>%  #exclude any cells below the red cutoff (i.e. exposed to virus but not infected)
  left_join(., temp1, by="unique_ID") %>%  #join infection start time data so that every unique cell is associated with its infection start time
  left_join(., temp2, by="unique_ID") 

#unique cells per condition

unique_cells <- data_merged %>% 
  group_by(Condition) %>% 
  dplyr::summarise(count=n_distinct(unique_ID))

unique_cells_all <- worked_filtered_infection_Scored %>% 
  group_by(Condition) %>% 
  dplyr:::summarise(count=n_distinct(unique_ID)) %>% 
  dplyr:::rename(total_cell_count=count)

unique_cells_original <- data_merged_intermediate
  group_by(Condition) %>% 
  dplyr:::summarise(count=n_distinct(unique_ID)) %>% 
  dplyr:::rename(total_cell_count=count)

unique_cells_all_infected <- plot_data %>% 
  group_by(unique_ID) %>% 
  filter(((start_time - 1) > min(Metadata_Frame, na.rm=TRUE) | min(Metadata_Frame, na.rm=TRUE) == 0 | min(Metadata_Frame, na.rm=TRUE) < 20)) %>% 
  ungroup() %>% 
  group_by(Condition) %>% 
  dplyr:::summarise(count=n_distinct(unique_ID)) %>% 
  dplyr:::rename(total_cell_count=count)

#Creates a df that summarises final timepoint red and green values
condition_compare = function(df, var_to_compare_1, var_to_compare_2) {
  temp<- df %>% 
    group_by(Condition, Metadata_Frame) %>% 
    dplyr:::mutate(min_red= min({{ var_to_compare_1 }})) %>% 
    dplyr:::mutate(max_red= max({{ var_to_compare_1 }})) %>% 
    dplyr:::mutate(Time_Mean_Red = mean({{ var_to_compare_1 }}, na.rm=TRUE))%>% 
    dplyr:::mutate(Time_Mean_Green = mean({{ var_to_compare_2 }}, na.rm=TRUE))%>% 
    dplyr:::summarise(mean_red = mean({{ var_to_compare_1 }}),
                      mean_green = mean({{ var_to_compare_2 }}),
                      max_red = mean({{ var_to_compare_1 }}),
                      min_red = mean({{ var_to_compare_1 }}),
                      sum_red = sum({{ var_to_compare_1 }}),
                      sum_green = sum({{ var_to_compare_2 }}))
}
condition_compare_df <- condition_compare(plot_data, normalised_sum_red,
                                          normalised_sum_green)

#Returns a df containing the earliest time point at which "channel1" crosses the corresponding
#threshold for every cell in "condition". Condition must be a value of Condition column in "df",
#and "channel1" must be the name of a column in "df" containing mean intensity data

infection_start_time = function(df, condition1, condition2, condition3, channel1, channel2){
  channel1 <- noquote(channel1)
  if (grepl("Red", channel1, fixed = TRUE)) {
    temp1<- df %>%
      filter(Condition=={{condition1}}) %>% 
      group_by(unique_ID) %>%
      filter({{channel2}} > cutoff_score_red) %>% 
      slice_min(order_by=Metadata_Frame)  
  } else {
    temp1<- df %>%
      filter(Condition=={{condition1}}) %>% 
      group_by(unique_ID) %>%
      filter({{channel2}} > cutoff_score_green) %>% 
      slice_min(order_by=Metadata_Frame) }
  
  if (grepl("Red", channel1, fixed = TRUE)) {
    temp2<- df %>%
      filter(Condition=={{condition2}}) %>% 
      group_by(unique_ID) %>%
      filter({{channel2}} > cutoff_score_red) %>% 
      slice_min(order_by=Metadata_Frame)  
  } else {
    temp2<- df %>%
      filter(Condition=={{condition2}}) %>% 
      group_by(unique_ID) %>%
      filter({{channel2}} > cutoff_score_green) %>% 
      slice_min(order_by=Metadata_Frame) }
  
  if (grepl("Red", channel1, fixed = TRUE)) {
    temp3<- df %>%
      filter(Condition=={{condition3}}) %>% 
      group_by(unique_ID) %>%
      filter({{channel2}} > cutoff_score_red) %>% 
      slice_min(order_by=Metadata_Frame)  
  } else {
    temp3<- df %>%
      filter(Condition=={{condition3}}) %>% 
      group_by(unique_ID) %>%
      filter({{channel2}} > cutoff_score_green) %>% 
      slice_min(order_by=Metadata_Frame) }
  
  as.data.frame(qpcR:::cbind.na(temp1$HPI, temp2$HPI, temp3$HPI)) %>% 
    dplyr:::rename(condition_1 = V1, condition_2 = V2, condition_3 = V3)
}

infection_start_time_df1 <- infection_start_time(data_merged, "MOI1", "MOI10", "MOI50","normalised_sum_red", normalised_mean_red)
infection_start_time_df2 <- infection_start_time(data_merged, "MOI1", "MOI10", "MOI50", "normalised_sum_green", normalised_mean_green)

start_time_frequency_plot_data <- worked_filtered_infection_Scored %>%
  group_by(unique_ID) %>%
  dplyr:::filter(normalised_sum_red > cutoff_score_red) %>% 
  slice_min(order_by=Metadata_Frame) %>% 
  group_by(Condition, Metadata_Frame) %>% 
  dplyr:::mutate(count = n_distinct(unique_ID)) %>% 
  dplyr:::summarise(count=first(count),
                    HPI=first(HPI))

start_time_frequency_plot_data_green <- worked_filtered_infection_Scored %>%
  group_by(unique_ID) %>%
  dplyr:::filter(normalised_sum_green > cutoff_score_green) %>% 
  slice_min(order_by=Metadata_Frame) %>% 
  group_by(Condition, Metadata_Frame) %>% 
  dplyr:::mutate(count = n_distinct(unique_ID)) %>% 
  dplyr:::summarise(count=first(count),
                    HPI=first(HPI))



#Creates a df containing infection start times tagged by condition for plotting/analysis
infection_start_time_long_red <- infection_start_time_df1 %>% 
  pivot_longer(cols=everything(), names_to="Condition", values_to="start_time") %>% 
  group_by(Condition) %>% 
  mutate(sd= sd(start_time, na.rm=TRUE),
         mean=mean(start_time, na.rm=TRUE))

infection_start_time_long_green <- infection_start_time_df2 %>% 
  pivot_longer(cols=everything(), names_to="Condition", values_to="start_time") %>% 
  group_by(Condition) %>% 
  mutate(sd= sd(start_time, na.rm=TRUE),
         mean=mean(start_time, na.rm=TRUE))

#Pull "Condition" INFECTION START TIMES FROM df AS A VECTOR
infection_start_time_vector=function(df, condition){
  df %>% 
    pull({{condition}})
}

infection_start_time_vector1= infection_start_time_vector(infection_start_time_df1, condition_1)
infection_start_time_vector2= infection_start_time_vector(infection_start_time_df1, condition_2)
infection_start_time_vector3= infection_start_time_vector(infection_start_time_df1, condition_3)
infection_start_time_vector3= infection_start_time_vector(infection_start_time_df1, condition_4)

#Generates the temporal gap between red and green passing their respective cutoffs
#in the same cell. i.e. approximate time to produce infectious progeny
RED_GREEN_LAG <- plot_data %>%
  group_by(unique_ID) %>% 
  filter(normalised_sum_red > cutoff_score_red) %>% 
  mutate(red_start = min(HPI)) %>% 
  filter(normalised_sum_green > cutoff_score_green)%>% 
  mutate(green_start = min(HPI))%>% 
  mutate(temporal_lag = ((start_time_green-start_time)*10)/60) 


lag_temp<- RED_GREEN_LAG %>% 
  group_by(unique_ID) %>% 
  dplyr::summarise(lag=first(temporal_lag),
                   start_green=first(start_time_green),
                   red_start=first(start_time)) %>% 
  group_by(Condition) %>% 
  dplyr::summarise(lag=mean(lag))
#GENERATES A SUMMARY DF SHOWING TEMPORAL LAG WITH A SINGLE VALUE
#PER CELL FOR USE IN PLOTTING AND STATISTICS
RED_GREEN_LAG_stats_plots_MOI <- RED_GREEN_LAG %>% 
  group_by(Condition) %>% 
  dplyr:::mutate(mean = mean(temporal_lag),
                 sd = sd(temporal_lag)) %>% 
  ungroup() %>% 
  group_by(unique_ID, Condition) %>% 
  dplyr:::summarise(mean_lag= mean(temporal_lag),
                    meansd_lag = mean(sd)) %>% 
  ungroup() %>% 
  group_by(Condition) %>% 
  dplyr:::mutate(mean = mean(mean_lag))

lag_summary<- RED_GREEN_LAG %>% 
  group_by(Condition) %>% 
  summarise(mean=mean(temporal_lag))


RED_GREEN_LAG_stats_plots_MOI_sicegar <- plot_data_with_sicegar_2_temp %>% 
  group_by(unique_ID) %>% 
  filter(DEC_decision_red!="ambiguous"&DEC_decision_red!="no_signal") %>% 
  slice(1) %>% 
  group_by(productive, Condition_red, DEC_decision_red) %>% 
  dplyr::summarise(n=n()) %>% 
  pivot_wider(values_from = n, names_from = DEC_decision_red) %>% 
  mutate(sigmoidal=coalesce(sigmoidal, 0),
         ratio=sigmoidal/double_sigmoidal) %>% 
  dplyr::select(Condition_red, productive,ratio) %>% 
  pivot_wider(names_from = productive, values_from = ratio) %>% 
  mutate(ratio_NP_over_P=NO/YES)


lag_summary<- RED_GREEN_LAG_stats_plots_MOI_sicegar %>% 
  group_by(DEC_decision_red, Condition_red) %>% 
  summarise(mean=mean(temporal_lag))

#Endpoint data for both channels per condition.
red_summary<- plot_data %>% 
  group_by(Condition) %>%
  dplyr:::filter(Metadata_Frame=="143") %>%
  dplyr:::mutate(sd= sd(normalised_sum_red, na.rm=TRUE),
                 mean=mean(normalised_sum_red, na.rm=TRUE))
green_summary <- plot_data %>% 
  group_by(Condition) %>%
  dplyr:::filter(Metadata_Frame=="143") %>%
  dplyr:::mutate(sd= sd(normalised_sum_green, na.rm=TRUE),
                 mean=mean(normalised_sum_green, na.rm=TRUE))

setwd(output_directory)
write.csv(plot_data, "plot_data.csv")
write.csv(plot_data_with_clustering, "plot_data_fulltimecourse_with_clustering.csv")
write.csv(condition_compare_df, "condition_compare_df.csv")
write.csv(red_summary, "red_summary.csv")
write.csv(green_summary, "green_summary.csv")
write.csv(RED_GREEN_LAG_stats_plots, "RED_GREEN_LAG_stats_plots.csv")
write.csv(infection_start_time_long_green, "infection_start_time_long_green.csv")
write.csv(infection_start_time_long_red, "infection_start_time_long_red.csv")
write.csv(start_time_frequency_plot_data, "start_time_frequency_plot_data.csv")

